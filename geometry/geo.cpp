#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef long double type;
//for big coordinates change to long long

//BASICS

  bool ge(type x, type y) { return x + EPS > y; }
  bool le(type x, type y) { return x - EPS < y; }
  bool eq(type x, type y) { return ge(x, y) and le(x, y); }

  struct point {
      type x, y;

      point() : x(0), y(0) {}
      point(type x, type y) : x(x), y(y) {}

      point operator -() { return point(-x, -y); }
      point operator +(point p) { return point(x+p.x, y+p.y); }
      point operator -(point p) { return point(x-p.x, y-p.y); }

      point operator *(type k) { return point(k*x, k*y); }
      point operator /(type k) { return point(x/k, y/k); }

      type operator *(point p) { return x*p.x + y*p.y; }
      type operator %(point p) { return x*p.y - y*p.x; }

      bool operator ==(point p) { return x == p.x and y == p.y; }
      bool operator !=(point p) { return x != p.x  or y != p.y; }
      bool operator <(const point p) const { return (x < p.x) or (x == p.x and y < p.y); }

      int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
      }

      bool on_seg(point p, point q) {
          if (this->dir(p, q)) return 0;
          return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
              ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
      }

      ld abs() { return sqrt(x*x + y*y); }
      type abs2() { return x*x + y*y; }
      ld dist(point q) { return (*this - q).abs(); }
      type dist2(point q) { return (*this - q).abs2(); }

      ld arg() { return atan2l(y, x); }

      // Project point on vector y
      point project(point y) { return y * ((*this * y) / (y * y)); }

      // Project point on line generated by points x and y
      point project(point x, point y) { return x + (*this - x).project(y-x); }

      ld dist_line(point x, point y) { return dist(project(x, y)); }

      ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
      }

      point rotate(ld sin, ld cos) { return point(cos*x-sin*y, sin*x+cos*y); }
      point rotate(ld a) { return rotate(sin(a), cos(a)); }
      // rotate around the argument of vector p
      point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }

  };


  point RotateCCW90(point p)   { return point(-p.y,p.x); }
  point RotateCW90(point p)    { return point(p.y,-p.x); }

  double dot(point p, point q)     { return p.x*q.x+p.y*q.y; }
  double cross(point p, point q)   { return p.x*q.y-p.y*q.x; }

  type area2(point a, point b, point c) { return cross(a,b) + cross(b,c) + cross(c,a); }

  ostream &operator<<(ostream &os, const point &p) {
    os << "(" << p.x << "," << p.y << ")"; 
    return os;
  }

  int direction(point o, point p, point q) { return p.dir(o, q); }

//LINES

  point ProjectPointLine(point a, point b, point c) {
    return a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
  }

  point ProjectPointSegment(point a, point b, point c) {
    double r = dot(b-a,b-a);
    if (fabs(r) < EPS) return a;
    r = dot(c-a, b-a)/r;
    if (r < 0) return a;
    if (r > 1) return b;
    return a + (b-a)*r;
  }

  double DistancePointSegment(point a, point b, point c) {
    return c.dist(ProjectPointSegment(a, b, c));
  }

  double DistancePointLine(point a, point b, point c) {
    return c.dist(ProjectPointLine(a, b, c));
  }

  double DistancePointPlane(double x, double y, double z,
                            double a, double b, double c, double d)
  {
    return fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);
  }

  bool LinesParallel(point a, point b, point c, point d) { 
    return fabs(cross(b-a, c-d)) < EPS; 
  }

  bool LinesCollinear(point a, point b, point c, point d) { 
    return LinesParallel(a, b, c, d)
        && fabs(cross(a-b, a-c)) < EPS
        && fabs(cross(c-d, c-a)) < EPS; 
  }

  bool SegmentsIntersect(point a, point b, point c, point d) {
    if (LinesCollinear(a, b, c, d)) {
      if (a.dist2(c) < EPS || a.dist2(d) < EPS ||
        b.dist2(c) < EPS || b.dist2(d) < EPS) return true;
      if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)
        return false;
      return true;
    }
    if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;
    if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;
    return true;
  }

  point lines_intersect(point p, point q, point a, point b) {
    point r = q-p, s = b-a, c(p%q, a%b);
    if (eq(r%s,0)) return point(INF, INF);
    return point(point(r.x, s.x) % c, point(r.y, s.y) % c) / (r%s);
  }

  point ComputeLineIntersection(point a, point b, point c, point d) {
    b=b-a; d=c-d; c=c-a;
    assert(dot(b, b) > EPS && dot(d, d) > EPS);
    return a + b*cross(c, d)/cross(b, d);
  }

//CIRCLES

  point ComputeCircleCenter(point a, point b, point c) {
    b=(a+b)/2;
    c=(a+c)/2;
    return ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));
  }

  struct circle {
    point c;
    double r;
    circle() { c = point(); r = 0; }
    circle(point _c, double _r) : c(_c), r(_r) {}
    double area() { return acos(-1.0)*r*r; }
    double chord(double rad) { return  2*r*sin(rad/2.0); }
    double sector(double rad) { return 0.5*rad*area()/acos(-1.0); }
    bool intersects(circle other) {
      return c.dist(other.c) < r + other.r;
    }
    bool contains(point p) { return c.dist(p) <= r + EPS; }
    pair<point, point> getTangentPoint(point p) {
      double d1 = c.dist(p), theta = asin(r/d1);
      point p1 = (c-p).rotate(-theta);
      point p2 = (c-p).rotate(theta);
      p1 = p1*(sqrt(d1*d1-r*r)/d1)+p;
      p2 = p2*(sqrt(d1*d1-r*r)/d1)+p;
      return make_pair(p1,p2);
    }
  };

  circle circumcircle(point a, point b, point c) {
    circle ans;
    point u = point((b-a).y, -(b-a).x);
    point v = point((c-a).y, -(c-a).x);
    point n = (c-b)*0.5;
    double t = cross(u,n)/cross(v,u);
    ans.c = ((a+c)*0.5) + (v*t);
    ans.r = ans.c.dist(a);
    return ans;
  }

  int insideCircle(point p, circle c) {
    if (fabs(p.dist(c.c) - c.r)<EPS) return 1;
    else if (p.dist(c.c) < c.r) return 0;
    else return 2;
  } //0 = inside/1 = border/2 = outside

  circle incircle( point p1, point p2, point p3 ) {
      double m1=p2.dist(p3);
      double m2=p1.dist(p3);
      double m3=p1.dist(p2);
      point c = (p1*m1+p2*m2+p3*m3)*(1/(m1+m2+m3));
      double s = 0.5*(m1+m2+m3);
      double r = sqrt(s*(s-m1)*(s-m2)*(s-m3))/s;
      return circle(c, r);
  }

  circle minimumCircle(vector<point> p) {
	random_shuffle(p.begin(), p.end());
	circle C = circle(p[0], 0.0);
	for(int i = 0; i < (int)p.size(); i++) {
		if (C.contains(p[i])) continue;
		C = circle(p[i], 0.0);
		for(int j = 0; j < i; j++) {
			if (C.contains(p[j])) continue;
			C = circle((p[j] + p[i])*0.5, 0.5*p[j].dist(p[i]));
			for(int k = 0; k < j; k++) {
				if (C.contains(p[k])) continue;
				C = circumcircle(p[j], p[i], p[k]);
			}
		}
	}
	return C;
}

  vector<point> CircleLineIntersection(point a, point b, point c, double r) {
    vector<point> ret;
    b = b-a;
    a = a-c;
    double A = dot(b, b);
    double B = dot(a, b);
    double C = dot(a, a) - r*r;
    double D = B*B - A*C;
    if (D < -EPS) return ret;
    ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);
    if (D > EPS)
      ret.push_back(c+a+b*(-B-sqrt(D))/A);
    return ret;
  }

  vector<point> CircleCircleIntersection(point a, point b, double r, double R) {
    vector<point> ret;
    double d = sqrt(a.dist2(b));
    if (d > r+R || d+min(r, R) < max(r, R)) return ret;
    double x = (d*d-R*R+r*r)/(2*d);
    double y = sqrt(r*r-x*x);
    point v = (b-a)/d;
    ret.push_back(a+v*x + RotateCCW90(v)*y);
    if (y > 0)
      ret.push_back(a+v*x - RotateCCW90(v)*y);
    return ret;
  }

//POLYGONS

  point origin;
  bool radial(point p, point q) {
    int dir = p.dir(origin, q);
    return dir > 0 or (!dir and p.on_seg(origin, q));
  }

  // Graham Scan
  vector<point> convex_hull(vector<point> pts) {
  vector<point> ch(pts.size());
  point mn = pts[0];

  for(point p : pts) if (p.y < mn.y or (p.y == mn.y and p.x < p.y)) mn = p;

  origin = mn;
  sort(pts.begin(), pts.end(), radial);

  int n = 0;

  // IF: Convex hull without collinear points
  for(point p : pts) {
    while (n > 1 and ch[n-1].dir(ch[n-2], p) < 1) n--;
    ch[n++] = p;
  }

  /* ELSE IF: Convex hull with collinear points
  for(point p : pts) {
    while (n > 1 and ch[n-1].dir(ch[n-2], p) < 0) n--;
    ch[n++] = p;
  }
  for(int i=pts.size()-1; i >=1; --i)
    if (pts[i] != ch[n-1] and !pts[i].dir(pts[0], ch[n-1]))
      ch[n++] = pts[i];
  // END IF */

  ch.resize(n);
  return ch;
}

  //Monotone chain
  #define REMOVE_REDUNDANT
  #ifdef REMOVE_REDUNDANT
  bool between(const point &a, const point &b, const point &c) {
    return (fabs(area2(a,b,c)) < EPS && (a.x-b.x)*(c.x-b.x) <= 0 && (a.y-b.y)*(c.y-b.y) <= 0);
  }
  #endif

  void ConvexHull(vector<point> &pts) {
  sort(pts.begin(), pts.end());
  pts.erase(unique(pts.begin(), pts.end()), pts.end());
  vector<point> up, dn;
  for (int i = 0; i < pts.size(); i++) {
    while (up.size() > 1 && area2(up[up.size()-2], up.back(), pts[i]) >= 0) up.pop_back();
    while (dn.size() > 1 && area2(dn[dn.size()-2], dn.back(), pts[i]) <= 0) dn.pop_back();
    up.push_back(pts[i]);
    dn.push_back(pts[i]);
  }
  pts = dn;
  for (int i = (int) up.size() - 2; i >= 1; i--) pts.push_back(up[i]);
  
#ifdef REMOVE_REDUNDANT
  if (pts.size() <= 2) return;
  dn.clear();
  dn.push_back(pts[0]);
  dn.push_back(pts[1]);
  for (int i = 2; i < pts.size(); i++) {
    if (between(dn[dn.size()-2], dn[dn.size()-1], pts[i])) dn.pop_back();
    dn.push_back(pts[i]);
  }
  if (dn.size() >= 3 && between(dn.back(), dn[0], dn[1])) {
    dn[0] = dn.back();
    dn.pop_back();
  }
  pts = dn;
#endif
}

  double ComputeSignedArea(const vector<point> &p) {
    double area = 0;
    for(int i = 0; i < p.size(); i++) {
      int j = (i+1) % p.size();
      area += p[i].x*p[j].y - p[j].x*p[i].y;
    }
    return area / 2.0;
  }

  double ComputeArea(const vector<point> &p) {
    return fabs(ComputeSignedArea(p));
  }

  point ComputeCentroid(vector<point> &p) {
    point c(0,0);
    double scale = 6.0 * ComputeSignedArea(p);
    for (int i = 0; i < p.size(); i++){
      int j = (i+1) % p.size();
      c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);
    }
    return c / scale;
  }

  bool IsSimple(const vector<point> &p) {
    for (int i = 0; i < p.size(); i++) {
      for (int k = i+1; k < p.size(); k++) {
        int j = (i+1) % p.size();
        int l = (k+1) % p.size();
        if (i == l || j == k) continue;
        if (SegmentsIntersect(p[i], p[j], p[k], p[l])) 
          return false;
      }
    }
    return true;
  }

  //O(N)
  bool PointInPolygon(vector<point> &p, point q) {
    bool c = 0;
    for (int i = 0; i < p.size(); i++){
      int j = (i+1)%p.size();
      if ((p[i].y <= q.y && q.y < p[j].y || 
        p[j].y <= q.y && q.y < p[i].y) &&
        q.x < p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
        c = !c;
    }
    return c;
  }

  // determine if point is on the boundary of a polygon (O(N))
  bool PointOnPolygon(vector<point> &p, point q) {
    for (int i = 0; i < p.size(); i++)
      if (q.dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q)) < EPS)
        return true;
      return false;
  }

  //find point in or on polygon O(logn)

//ALL PAIRS

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    return 0;
}